import { describe, test, expect, beforeEach } from 'vitest';
import TypeScriptInterfaceGenerator from '../../src/codegen/interface-generator.js';

describe('TypeScriptInterfaceGenerator', () => {
  let generator;

  beforeEach(() => {
    generator = new TypeScriptInterfaceGenerator();
  });

  describe('Interface Generation', () => {
    test('should generate basic interfaces', () => {
      const schemas = {
        User: {
          type: 'object',
          properties: {
            id: { type: 'number' },
            name: { type: 'string' },
            email: { type: 'string' }
          },
          required: ['id', 'name']
        }
      };

      const result = generator.generateInterfaces(schemas);
      
      expect(result).toContain('export interface User');
      expect(result).toContain('id: number;');
      expect(result).toContain('name: string;');
      expect(result).toContain('email?: string;');
      expect(result).toContain('Generated by SpecJet CLI');
    });

    test('should generate interfaces with descriptions', () => {
      const schemas = {
        User: {
          type: 'object',
          description: 'User account information',
          properties: {
            id: { 
              type: 'number',
              description: 'Unique user identifier'
            }
          }
        }
      };

      const result = generator.generateInterfaces(schemas);
      
      expect(result).toContain('User account information');
      expect(result).toContain('Unique user identifier');
    });

    test('should generate enum types', () => {
      const schemas = {
        Status: {
          type: 'string',
          enum: ['active', 'inactive', 'pending'],
          description: 'User status'
        }
      };

      const result = generator.generateInterfaces(schemas);
      
      expect(result).toContain('export type Status');
      expect(result).toContain("'active' | 'inactive' | 'pending'");
      expect(result).toContain('User status');
    });

    test('should generate union types from oneOf', () => {
      const schemas = {
        StringOrNumber: {
          oneOf: [
            { type: 'string' },
            { type: 'number' }
          ]
        }
      };

      const result = generator.generateInterfaces(schemas);
      
      expect(result).toContain('export type StringOrNumber');
      expect(result).toContain('string | number');
    });

    test('should generate intersection types from allOf', () => {
      const schemas = {
        AdminUser: {
          allOf: [
            { $ref: '#/components/schemas/User' },
            { 
              type: 'object',
              properties: {
                permissions: { 
                  type: 'array',
                  items: { type: 'string' }
                }
              }
            }
          ]
        }
      };

      const result = generator.generateInterfaces(schemas);
      
      expect(result).toContain('export type AdminUser');
      expect(result).toContain('&');
    });
  });

  describe('Complex Schema Handling', () => {
    test('should handle nested objects', () => {
      const schemas = {
        User: {
          type: 'object',
          properties: {
            profile: {
              type: 'object',
              properties: {
                firstName: { type: 'string' },
                lastName: { type: 'string' }
              }
            }
          }
        }
      };

      const result = generator.generateInterfaces(schemas);
      
      expect(result).toContain('profile?:');
      expect(result).toContain('firstName?: string');
      expect(result).toContain('lastName?: string');
    });

    test('should handle arrays of objects', () => {
      const schemas = {
        UserList: {
          type: 'object',
          properties: {
            users: {
              type: 'array',
              items: { $ref: '#/components/schemas/User' }
            }
          }
        }
      };

      const result = generator.generateInterfaces(schemas);
      
      expect(result).toContain('users?: Array<User>');
    });

    test('should handle empty properties object', () => {
      const schemas = {
        EmptyObject: {
          type: 'object',
          properties: {}
        }
      };

      const result = generator.generateInterfaces(schemas);
      expect(result).toContain('export interface EmptyObject');
      expect(result).toContain('// No properties defined');
    });
  });

  describe('Schema Processing', () => {
    test('should prevent infinite recursion with processed schemas tracking', () => {
      // This tests that the processedSchemas set prevents infinite loops
      const schemas = {
        Node: {
          type: 'object',
          properties: {
            value: { type: 'string' },
            parent: { $ref: '#/components/schemas/Node' }
          }
        }
      };

      expect(() => generator.generateInterfaces(schemas)).not.toThrow();
      const result = generator.generateInterfaces(schemas);
      expect(result).toContain('export interface Node');
      expect(result).toContain('parent?: Node');
    });

    test('should handle multiple schemas in correct order', () => {
      const schemas = {
        User: {
          type: 'object',
          properties: {
            id: { type: 'number' },
            profile: { $ref: '#/components/schemas/Profile' }
          }
        },
        Profile: {
          type: 'object',
          properties: {
            name: { type: 'string' }
          }
        }
      };

      const result = generator.generateInterfaces(schemas);
      expect(result).toContain('export interface User');
      expect(result).toContain('export interface Profile');
    });
  });

  describe('File Template Wrapping', () => {
    test('should wrap content in file template with header', () => {
      const schemas = {
        Simple: {
          type: 'object',
          properties: {
            id: { type: 'number' }
          }
        }
      };

      const result = generator.generateInterfaces(schemas);
      
      expect(result).toContain('// ‼️ DO NOT EDIT ‼️');
      expect(result).toContain('Generated by SpecJet CLI');
      expect(result).toMatch(/Generated by SpecJet CLI on \d+\/\d+\/\d+/);
    });
  });

  describe('Property and Comment Handling', () => {
    test('should handle properties with special characters in names', () => {
      const schemas = {
        SpecialProps: {
          type: 'object',
          properties: {
            'kebab-case': { type: 'string' },
            'with spaces': { type: 'number' },
            'special@chars': { type: 'boolean' }
          }
        }
      };

      const result = generator.generateInterfaces(schemas);
      
      expect(result).toContain("'kebab-case'?: string");
      expect(result).toContain("'with spaces'?: number");
      expect(result).toContain("'special@chars'?: boolean");
    });

    test('should handle JSDoc comments correctly', () => {
      const schemas = {
        Documented: {
          type: 'object',
          description: 'A well documented interface',
          properties: {
            field: {
              type: 'string',
              description: 'A documented field'
            }
          }
        }
      };

      const result = generator.generateInterfaces(schemas);
      
      expect(result).toContain('/**\n * A well documented interface\n */');
      expect(result).toContain('/** A documented field */');
    });
  });
});