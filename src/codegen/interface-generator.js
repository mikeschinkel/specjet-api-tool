import TypeMapper from './type-mapper.js';

class TypeScriptInterfaceGenerator {
  constructor() {
    this.typeMapper = new TypeMapper();
  }
  
  generateInterfaces(schemas) {
    const interfaces = [];
    const processedSchemas = new Set(); // Prevent infinite recursion
    
    for (const [name, schema] of Object.entries(schemas)) {
      if (!processedSchemas.has(name)) {
        interfaces.push(this.schemaToInterface(name, schema, schemas, processedSchemas));
      }
    }
    
    return this.wrapInFileTemplate(interfaces.join('\n\n'));
  }
  
  schemaToInterface(name, schema, allSchemas = {}, processedSchemas = new Set()) {
    processedSchemas.add(name);
    
    // Handle different schema types
    if (schema.enum) {
      return this.generateEnumType(name, schema);
    }
    
    if (schema.oneOf) {
      return this.generateUnionType(name, schema.oneOf, allSchemas);
    }
    
    if (schema.allOf) {
      return this.generateIntersectionType(name, schema.allOf, allSchemas);
    }
    
    if (schema.type === 'object' || schema.properties) {
      return this.generateObjectInterface(name, schema, allSchemas);
    }
    
    // Fallback for other types
    const tsType = this.typeMapper.mapOpenApiTypeToTypeScript(schema, allSchemas);
    return `export type ${name} = ${tsType};`;
  }
  
  generateObjectInterface(name, schema, allSchemas) {
    const properties = [];
    const comments = [];
    
    // Add description as JSDoc comment
    if (schema.description) {
      comments.push(`/**\n * ${schema.description}\n */`);
    }
    
    if (schema.properties) {
      for (const [propName, propSchema] of Object.entries(schema.properties)) {
        const isRequired = schema.required?.includes(propName);
        const propType = this.typeMapper.mapOpenApiTypeToTypeScript(propSchema, allSchemas);
        
        // Add property description as comment
        let propLine = '';
        if (propSchema.description) {
          propLine += `  /** ${propSchema.description} */\n`;
        }
        
        propLine += `  ${this.typeMapper.escapePropertyName(propName)}${isRequired ? '' : '?'}: ${propType};`;
        properties.push(propLine);
      }
    }
    
    const commentBlock = comments.length > 0 ? comments.join('\n') + '\n' : '';
    const propertiesBlock = properties.length > 0 ? properties.join('\n') : '  // No properties defined';
    
    return `${commentBlock}export interface ${name} {\n${propertiesBlock}\n}`;
  }
  
  generateEnumType(name, schema) {
    const values = schema.enum.map(value => 
      typeof value === 'string' ? `'${value}'` : value
    ).join(' | ');
    
    const description = schema.description ? `/** ${schema.description} */\n` : '';
    return `${description}export type ${name} = ${values};`;
  }
  
  generateUnionType(name, oneOfSchemas, allSchemas) {
    const types = oneOfSchemas.map(schema => 
      this.typeMapper.mapOpenApiTypeToTypeScript(schema, allSchemas)
    ).join(' | ');
    
    return `export type ${name} = ${types};`;
  }
  
  generateIntersectionType(name, allOfSchemas, allSchemas) {
    const types = allOfSchemas.map(schema => 
      this.typeMapper.mapOpenApiTypeToTypeScript(schema, allSchemas)
    ).join(' & ');
    
    return `export type ${name} = ${types};`;
  }
  
  wrapInFileTemplate(content) {
    const timestamp = new Date().toLocaleString();
    const header = `// ‼️ DO NOT EDIT ‼️ This file is automatically generated
// Generated by SpecJet CLI on ${timestamp}

`;
    
    return header + content;
  }
}

export default TypeScriptInterfaceGenerator;